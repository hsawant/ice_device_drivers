/*******************************************************************************
 * Copyright (c) 2012 MD PnP Program.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v3.0
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 ******************************************************************************/
/**
 * @file    devcomm.h
 * @brief   Handle device data i/o for serial and analog (pcmmio) ports.
 *
 *          For each port type this defines a class for three different data
 *          sources: 1) Data obtained from an attached device; 2) Data
 *          generated by a program algorithm; 3) Data obtained from a
 *          specified sample data file.
 *
 * @see     Serial Program Guide for POSIX Operating Systems, at
 *          http://www.easysw.com/~mike/serial/serial.html
 */
//=============================================================================
#pragma once
#ifndef  DEVCOMM_H_
#define  DEVCOMM_H_

#include "projstd.h"
#include <string>
#include <cstdio>
#include <vector>

class serial_sample_file;
class analog_sample_file;

//=============================================================================
class devcomm
{
private:
// Disallow use of implicitly generated member functions:
  devcomm(const devcomm &src);
  devcomm &operator=(const devcomm &rhs);

protected:
  bool _isopen;
  std::string  _sstatusmsg;

public:

//=============================================================================
enum
{
  devcomm_rc_ok = 0,
  devcomm_rc_fail = 1,
  devcomm_rc_bufferoverrun,
  devcomm_rc_stopsignal,
  devcomm_rc_timeout,
  devcomm_rc_alreadyopen,
  devcomm_rc_eof

}  result_code_devcomm;

//=============================================================================
devcomm();
virtual ~devcomm();

virtual int initialize(int argc, char *argv[]) = 0;
virtual int close();
virtual int open();
virtual bool isopen() const;

inline std::string getstatusmsg() const { return _sstatusmsg; }

//=============================================================================
static inline const bool result_code_ok(const int rc)
{
  return(rc == devcomm_rc_ok);
}

};

//=============================================================================
// devcomm_rs232 object
//=============================================================================
#ifdef  _WIN32
// Windows world

#include <conio.h>
#include <stdio.h>
#else
// Not Windows world

#include <stdio.h>  /* Standard input/output definitions */
#include <string.h> /* String function definitions */
#include <unistd.h> /* UNIX standard function definitions */
#include <fcntl.h>  /* File control definitions */
#include <termios.h>  /* POSIX terminal control definitions */
#include <sys/select.h>

#ifndef  INVALID_HANDLE_VALUE
#define  INVALID_HANDLE_VALUE  (-1)
#endif
#endif

//=============================================================================
class comm_rs232 : public devcomm
{
private:
// Disallow use of implicitly generated member functions:
  comm_rs232(const comm_rs232 &src);
  comm_rs232 &operator=(const comm_rs232 &rhs);

  static const std::string _default_portname;

#ifdef  _WIN32
  HANDLE _hfile;
#else
  int _hfile;
  struct termios _saveoptions;
#endif

  int       _isysererrno;
  size_t    _ibytesxferredcount;

  std::string _cfgFile;
  std::string _portname;
  int _baudrate;
  int _databits;

  // value 0 -> 1 stop bit, 1 -> 1.5 stop bits, 2 -> 2 stop bits
  int _stopbits;
  int _handshaking;
  std::string  _parity;

  int parse_config(int argc, char *argv[]);

public:

comm_rs232();
virtual ~comm_rs232();

virtual int initialize(int argc, char *argv[]);
virtual int close();
virtual int open();
virtual bool isopen() const;

void clearcommerror();
void flush();
int writerecord(const unsigned char *sbuf, const unsigned int ibytestoxfer);

static void print_cmd_line_help();

//=============================================================================
/**
 * Read bytes from the serial port and copy them to buffer sbuf.
 * Stop when the byte just read matches the specified terminator.
 */
virtual int readrecord(
  unsigned char *sbuf,
  const unsigned int ibuffersize,
  const int terminator);

//=============================================================================
int readchar(
  unsigned char *psbuf,
  unsigned int *pbytesxferredcount,
  const unsigned int ibytestoxfer = 1);

//=============================================================================
inline std::string get_portname() const { return(_portname); }
inline int get_baudrate() const { return(_baudrate); }
inline int get_databits() const { return(_databits); }
inline int get_stopbits() const { return(_stopbits); }
inline int get_handshaking() const { return(_handshaking); }
inline std::string get_parity() const { return(_parity); }

inline void set_portname(const std::string &ss) { _portname = ss; }
inline void set_baudrate(const int xx) { _baudrate = xx; }
inline void set_databits(const int xx) { _databits = xx; }
inline void set_stopbits(const int xx) { _stopbits = xx; }
inline void set_handshaking(const int xx) { _handshaking = xx; }
inline void set_parity(const std::string &ss) { _parity = ss; }
//=============================================================================

inline const unsigned int bytesxferredcount() const { return(_ibytesxferredcount); }

#ifndef  _WIN32
//=============================================================================
// Not-Windows baudrate constants

static speed_t baudrate(const int ibaud);
#endif

};

//=============================================================================
// rs232_sim object
//=============================================================================

//=============================================================================
class rs232_sim : public comm_rs232
{
private:
// Disallow use of implicitly generated member functions:
  rs232_sim(const rs232_sim &src);
  rs232_sim &operator=(const rs232_sim &rhs);
  rs232_sim();

  std::string _sample_string;
public:

rs232_sim(const char *sample_string);
~rs232_sim();

int close();
int open();
bool isopen() const;

//=============================================================================
/**
 * Copy the sample string to buffer sbuf.
 */
int readrecord(
  unsigned char *sbuf,
  const unsigned int ibuffersize,
  const int terminator);

//=============================================================================
inline std::string get_sample_string() const { return(_sample_string); }
inline void set_sample_string(const std::string &ss) { _sample_string = ss; }

};

//=============================================================================
// rs232_file_sim object
//=============================================================================

//=============================================================================
class rs232_file_sim : public comm_rs232
{
private:
// Disallow use of implicitly generated member functions:
  rs232_file_sim(const rs232_file_sim &src);
  rs232_file_sim &operator=(const rs232_file_sim &rhs);
  rs232_file_sim();

  serial_sample_file *_samplefile;

public:

rs232_file_sim(std::string &filename);
~rs232_file_sim();

int close();
int open();
bool isopen() const;

//=============================================================================
/**
 * Read bytes from the sample file and copy them to buffer sbuf.
 * Stop when the byte just read matches the specified terminator.
 */
int readrecord(
  unsigned char *sbuf,
  const unsigned int ibuffersize,
  const int terminator);

std::string get_filename() const;
void set_filename(const std::string &ss);

};

//=============================================================================
// comm_analog object
//=============================================================================
class comm_analog : public devcomm
{
private:
// Disallow use of implicitly generated member functions:
  comm_analog(const comm_analog &src);
  comm_analog &operator=(const comm_analog &rhs);

  std::string _cfgFile;
  int _deviceNumber;  // pcmmio device number
  std::vector<int> _channel_number;

  int parse_config(int argc, char *argv[]);

public:

enum { max_channels_default = 2 };

comm_analog();
virtual ~comm_analog();

virtual int initialize(int argc, char *argv[]);
virtual int close();
virtual int open();
virtual bool isopen() const;

virtual int readchannel(int ichannel, float *pval);

static void print_cmd_line_help();

inline int get_channel_count() const { return _channel_number.size(); }
inline void set_channel_count(int xx) { _channel_number.resize(xx); }
inline int get_deviceNumber() const { return _deviceNumber; }
inline void set_deviceNumber(const int xx) { _deviceNumber = xx; }

};

//=============================================================================
// analog_sim object
//=============================================================================

//=============================================================================
class analog_sim : public comm_analog
{
private:
// Disallow use of implicitly generated member functions:
  analog_sim(const analog_sim &src);
  analog_sim &operator=(const analog_sim &rhs);

  std::string _sample_string;
public:

analog_sim();
~analog_sim();

int close();
int open();
bool isopen() const;

int readchannel(int ad_channel, float *pval);
static int get_channel_count() { return comm_analog::max_channels_default; }

};

//=============================================================================
// analog_file_sim object
//=============================================================================

//=============================================================================
class analog_file_sim : public comm_analog
{
private:
// Disallow use of implicitly generated member functions:
  analog_file_sim(const analog_file_sim &src);
  analog_file_sim &operator=(const analog_file_sim &rhs);
  analog_file_sim();

  analog_sample_file *_samplefile;

public:

analog_file_sim(std::string &filename);
~analog_file_sim();

int close();
int open();
bool isopen() const;

//=============================================================================
/**
 * Read bytes from the sample file and copy them to buffer sbuf.
 * Stop when the byte just read matches the specified terminator.
 */
int readchannel(int ad_channel, float *pval);
std::string get_filename() const;
void set_filename(const std::string &ss);

};

#endif
